/*
 * Copyright (c) 2012-2019 LabKey Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.labkey.api.assay;

import org.apache.commons.io.FileUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.Nullable;
import org.labkey.api.assay.actions.AssayRunUploadForm;
import org.labkey.api.exp.ExperimentException;
import org.labkey.api.exp.api.ExpData;
import org.labkey.api.exp.api.ExpRun;
import org.labkey.api.query.BatchValidationException;
import org.labkey.api.util.FileUtil;
import org.labkey.api.util.NetworkDrive;
import org.labkey.vfs.FileLike;

import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * User: jeckels
 * Date: 8/17/12
 */
public abstract class AbstractTempDirDataCollector<ContextType extends AssayRunUploadContext<? extends AssayProvider>> extends AbstractAssayDataCollector<ContextType>
{
    protected boolean _uploadComplete = false;
    private static final String TMPFILE = "tmp";

    private static final Logger LOG = LogManager.getLogger(AbstractTempDirDataCollector.class);

    private void removeTempDir(ContextType context) throws ExperimentException
    {
        // TODO: remove this instanceof check
        if (!(context instanceof AssayRunUploadForm))
            return;

        String uploadAttemptID = ((AssayRunUploadForm)context).getUploadAttemptID();

        // Cleanup files other than input generated by transform scripts
        FileLike tempDir = ensureSubdirectory(context.getContainer(), TEMP_DIR_NAME);
        FileLike uploadAttemptDir = tempDir.resolveChild(uploadAttemptID);
        if (NetworkDrive.exists(uploadAttemptDir))
        {
            try
            {
                FileUtils.deleteDirectory(uploadAttemptDir.toNioPathForWrite().toFile());
            }
            catch (IOException e)
            {
                // Delete quietly
            }
        }
    }

    private void removeFiles(ContextType context, Collection<Map<String, File>> assayFiles) throws ExperimentException
    {
        for (Map<String, File> fileMap : assayFiles)
        {
            for (File file : fileMap.values())
            {
                FileLike assayFile = ensureUploadDirectory(context.getContainer(), DIR_NAME).resolveChild(file.getName());
                FileUtils.deleteQuietly(assayFile.toNioPathForWrite().toFile());
            }
        }
    }

    protected void uploadFailed(ContextType context, List<Map<String, File>> assayFiles) throws ExperimentException
    {
        removeTempDir(context);
        removeFiles(context, assayFiles);
    }

    @Override
    public void initDir(ContextType context) throws ExperimentException
    {
        // If upload files are specified
        if (!context.getUploadedData().isEmpty())
        {
            // TODO: remove this instanceof check
            if (!(context instanceof AssayRunUploadForm))
                return;

            String uploadAttemptID = ((AssayRunUploadForm)context).getUploadAttemptID();

            // Cleanup transform script output files if generated by warning feature
            FileLike tempDir = AssayFileWriter.ensureSubdirectory(context.getContainer(), TEMP_DIR_NAME);
            FileLike uploadAttemptDir = tempDir.resolveChild(uploadAttemptID);
            if (NetworkDrive.exists(uploadAttemptDir))
            {
                Collection<FileLike> fileList = uploadAttemptDir.getChildren();
                for (FileLike file : fileList)
                {
                    boolean save = false;

                    // Loop through primary files to ensure we don't delete
                    for (Map.Entry<String, FileLike> entry : context.getUploadedData().entrySet())
                    {
                        if (entry.getValue().equals(file) && entry.getKey().startsWith(AssayDataCollector.PRIMARY_FILE))
                        {
                            save = true;
                            break;
                        }
                    }

                    if (!save)
                    {
                        FileUtils.deleteQuietly(file.toNioPathForWrite().toFile());
                    }
                }
            }
        }
    }

    @Override
    protected FileLike getFileTargetDir(ContextType context) throws ExperimentException
    {
        if (context instanceof AssayRunUploadForm)
        {
            FileLike uploadAttemptDir = null;

            try
            {
                FileLike tempDir = ensureSubdirectory(context.getContainer(), TEMP_DIR_NAME);
                uploadAttemptDir = tempDir.resolveChild(((AssayRunUploadForm)context).getUploadAttemptID());

                if (!NetworkDrive.exists(uploadAttemptDir))
                {
                    FileUtil.mkdirs(uploadAttemptDir);
                }
                if (!uploadAttemptDir.isDirectory())
                {
                    throw new IOException();
                }
            }
            catch (IOException e)
            {
                throw new ExperimentException("Unable to create temporary assay directory " + uploadAttemptDir);
            }

            return uploadAttemptDir;
        }
        else
        {
            return super.getFileTargetDir(context);
        }
    }

    // This is the default case to get a unique file name in the assayData directory for the primary file
    @Nullable
    protected FileLike getFilePath(ContextType context, @Nullable ExpRun run, FileLike tempDirFile) throws ExperimentException
    {
        FileLike assayDir = ensureUploadDirectory(context.getContainer());
        return findUniqueFileName(tempDirFile.getName(), assayDir);
    }

    // This is the default case to move the primary file from the temp directory to the assayData directory
    protected void handleTempFile(File tempDirFile, File assayDirFile) throws IOException
    {
        FileUtils.moveFile(tempDirFile, assayDirFile);
    }

    @Override
    public Map<String, FileLike> uploadComplete(ContextType context, @Nullable ExpRun run) throws ExperimentException
    {
        Map<FileLike, String> fileToName = new HashMap<>();
        Map<String, FileLike> uploadedData = context.getUploadedData();
        Map<String, FileLike> result = new HashMap<>(uploadedData);
        for (Map.Entry<String, FileLike> entry : uploadedData.entrySet())
        {
            fileToName.put(entry.getValue(), entry.getKey());
        }

        // Copy the data files from the temp directory into the real assay directory, and fix up any references
        // to the file that are stored in the exp.data table
        try
        {
            List<? extends ExpData> allData = run == null ? Collections.emptyList() : run.getAllDataUsedByRun();
            FileLike assayDir = ensureUploadDirectory(context.getContainer());
            FileLike tempDir = getFileTargetDir(context);
            for (FileLike tempDirFile : tempDir.getChildren())
            {
                FileLike assayDirFile = getFilePath(context, run, tempDirFile);
                if (assayDirFile != null)
                {
                    String uploadName = fileToName.get(tempDirFile);
                    if (uploadName != null)
                    {
                        result.put(uploadName, assayDirFile);
                    }
                    for (ExpData expData : allData)
                    {
                        if (tempDirFile.equals(expData.getFileLike()))
                        {
                            // Note, setDataFileURI() calls ExpData.normalizeDataFileURI()
                            expData.setDataFileURI(assayDirFile.toURI());
                            expData.save(context.getUser());
                        }
                    }
                    if (run != null)
                    {
                        // Fixup the path in the run itself so that it's not pointed at the temp directory
                        run.setFilePathRoot(assayDir.toNioPathForRead().toFile());

                        // If the run name is the filename, and the filename was changed to another unique value, change the run name.
                        if (run.getName().equals(tempDirFile.getName()))
                        {
                            run.setName(getPreferredAssayId(assayDirFile));
                        }

                        run.save(context.getUser());
                    }
                    handleTempFile(tempDirFile.toNioPathForWrite().toFile(), assayDirFile.toNioPathForWrite().toFile());
                }
                else
                {
                    LOG.warn("Unable to resolve import/upload file location for file: " + tempDirFile);
                }
            }
            FileUtils.deleteDirectory(tempDir.toNioPathForWrite().toFile());
        }
        catch (IOException | BatchValidationException e)
        {
            throw new ExperimentException(e);
        }
        _uploadComplete = true;

        return result;
    }

    /** @return the preferred name for the run given the primary data file */
    protected String getPreferredAssayId(File primaryFile)
    {
        return primaryFile.getName();
    }

    protected String getPreferredAssayId(FileLike primaryFile)
    {
        return primaryFile.getName();
    }

    @Override
    public boolean isVisible()
    {
        return true;
    }
}
